# RougeDHCPSnooper
A rogue DHCP snooper in Python

<b>Major Features</b>

•	Validates DHCP messages received from sources and filters out invalid messages.

•	Alerts the user of Rogue DHCP servers and prints the IP and MAC address of the device.

<b>DHCP Application Layer Network Communications</b>

DHCP is an application layer protocol which is used to provide a subnet mask, router address, DNS address, and a vendor class identifier. DHCP is based on a client-server model as well as discovery, offer, request, and ACK (saurabhsharma56, 2018). The DHCP port number is 67 on the server-side and 68 for the client which uses UDP services. The client and server exchange 4 DHCP messages in order to make a connection, but there is a total of 8 exchanges in the process.
1.	DHCP Discover- Generated by the client host to see if there are any DHCP server(s) on the network.
2.	DHCP Offer- The server offers an unleased IP address and other TCP configuration information.
3.	DHCP Request- The client’s response to find any other host on the network with the same IP address. If no other host is found a message is broadcasted to the server accepting the IP address and adding a Client ID.
4.	DHCP Acknowledgment- The server makes an entry with the specific Client ID and binds the IP address offered with lease time.
5.	DHCP Negative Acknowledgment-If the server is distributing all IP addresses, or the pool is empty then this message is sent to the client.
6.	DHCP Decline-When the client determines that the offered configuration parameters are different or invalid, meaning the IP address is already in use.
7.	DHCP Release-This message is sent to release the IP address and cancel any remaining lease time.
8.	DHCP Inform-If the client address is obtained manually then the client uses a DHCP inform to obtain other local configuration parameters. The DHCP server will generate an ACK message with local configurations suitable for the client without allocating a new IP address.

<b>Data Needs</b>

To solve this problem, we will need the help of Scapy. We will first build a DHCP Discover packet and then use Scapy to send the packet to all connected LANs and wait for replies to detect both legit and rogue DHCP servers. Other data types we will need are the logging processes, subprocesses, and regular expressions.

We will need to identify network interfaces, check the IP address range, and then an external text file provided by the user with whitelisted DHCP servers. We will need to create a DHCP Discover packet and store MAC and IP addresses pairs. I will need to complete an inventory of all resources on the network and add them to my network map. Mapping the network will help me see where DHCP is occurring and help to locate the rogue server physically to identify IP address conflicts.

<b>Data, Data Types & Transformations</b>

I will need to create a DHCP discover packet data to scan for DHCP offer packets. A DHCP offer packet is sent by a DHCP server when a client sends out a broadcast packet looking to discover a DHCP server. It will know it is a rogue server if the IP address is not in range by checking the dhcp.txt document.

The program will read allowed DHCP servers from an external file, list and extract all network interfaces on the host using subprocess.run and re.findall and extract the interface names. Subprocess.run takes a list of arguments, and when the method is called, it executes the command and waits for the process to finish (Kumar, 2020). re.findall returns all non-overlapping matches of pattern in a string as a list of strings (nikhilaggarwal3 & rkbhola5, 2022). 

To detect the rogue DHCP server, I’m going to use a negated if statement, something like 
if interface != “lo” hw = get_if_raw_hwaddr(interface)[1].

To create the DHCP discover packet, we will need destination address, source, source and destination ports, bootstrap protocol, and options for the DHCP. 

Another line of code provided by scapy will send the discover packet and accept multiple answers for the same discover packet. ans, unans = srp(dhcp_discover, multi = True, iface = interface, timeout = 5, verbose = 0).

The program then creates a dictionary of MAC/IP pairs with mac_ip = {} which it will check to see if it is on the approved list. The program then prints a statement with the IP and MAC address stating whether it is an approved or rogue device.

<b>Functions</b>

Functions that are used:

•	from scapy.all import * will import scapy 

•	checkIPaddr = False will check IP parameters and assign any answer packet the IP address of the replying DHCP server as its source IP address. Given that the IP addresses don’t match, we disable Scapy’s check by setting the check IP address to False.

•	allowed_dhcp_server will read the allowed DHCP server file to check if the device is whitelisted

•	host_if  will list all network interfaces on the host

•	interfaces will extract interface names 

•	mac_add gets MAC addresses 

•	dhcp_discover creates the DHCP Discover packet 

•	snd_discover sends the discover packet 

•	macip_pair will define a dictionary to store MAC IP address pairs

<b>Network Functionality</b>

The data that gets sent is the network interfaces and interface names. We create a DHCP Discover packet, unmangled by gathering the destination address and source addresses and destination and source packets, and then we analyze the replies. We grab the MAC and IP addresses of the replies and create a dictionary. We specify multi =True, allowing Scapy to wait for more answer packets after receiving the first response. Scapy will usually make sure replies come from the same IP address that the stimulus was sent, but we are sending our DHCP packet to the IP broadcast address 255.255.255.255 (Scapy, n.d.). Any answer packet will have the IP address of the replying DHCP server as its source IP address. Since these IP addresses won’t match, we disable Scapy’s check with conf.checkIPaddr = False.

<b>Will you be doing any system interaction?</b>

The program interacts with the system while importing Scapy.

<b>Network and System Interaction Functions</b>

•	import sys lets us access system-specific parameters and functions.

•	for interface in interfaces:

    if interface != "lo": detects rogue DHCP servers per interface on all but the loopback interface
    
•	hw = get_if_raw_hwaddr(interface)[1]gets the hardware address

•	dhcp_discover = Ether(dst = "ff:ff:ff:ff:ff:ff") / IP(src = "0.0.0.0", dst = "255.255.255.255") / UDP(sport = 68, dport = 67) / BOOTP(chaddr = hw) / DHCP(options = [("message-type", "discover"), "end"]) creates DHCP Discover packet

•	ans, unans = srp(dhcp_discover, multi = True, iface = interface, timeout = 5, verbose = 0) sends the Discover packet and excepts multiple answers for the same Discover packet

•	for pair in ans:

   mac_ip[pair[1][Ether].src] = pair[1][IP].src MAC/IP pair
   
•	for mac, ip in mac_ip.items():

    if ip in allowed_dhcp_servers: checks for the MAC and IP address are in the allowed list

<b>Necessary Modules</b>

import logging uses “logger” to log messages

import re allows us to match or find other strings or sets of strings, using a specialized syntax held in a pattern

import subprocess lets us run new code and start new applications, connect to input/output/error pipes, and obtain their return codes

import sys provides variables for better control over input or output

<b>Exceptions</b>

The following will appear if Scapy is unsuccessful installing.

except ImportError:

	print (“Scapy is not installed on your system.”)
  
	print(“Try using: sudo pip3.8 install scapy”)
  
sys.exit()

The following three lines of logging code will suppress any message with a lower level of seriousness than error messages.

logging.getLogger("scapy.runtime").setLevel(logging.ERROR)

logging.getLogger("scapy.interactive").setLevel(logging.ERROR)

logging.getLogger("scapy.loading").setLevel(logging.ERROR)
